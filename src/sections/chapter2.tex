\section{AST search engine}

\subsection{Hashing of code fragments}

The one to one AST comparison method is slow and isn't applicable in practice.
We need hashing mechanism for AST where similar AST have same hash codes. For this we
introduce our Approximate Code Tree (ACT) structure. ACT is a method fingerprint,
which we use for our hashing function. We produce ACT from single method AST by
throwing away irrelevant information, generalizing types, normalizing expressions and replacing some construction with
wildcards. We work at method level, so as a disvantage we cannot handle
refactoring such as a method inlining or method extraction.

First in our hashing function we can ignore variable names. The primitive types
we preserve as is. In Java there are 8 primitive data types which we should
preserve in our hashing mechanism: boolean type, Unicode character type, 8-,
16-, 32-, 64-bit signed integers, IEEE 754 double- and single-precision floating numbers. As an option
we can generalize all integer and floating types which are semantically similar.

Class type handling is different. To properly handle the class types we need to
have information about full project class hierarchy. It means that we should parse not
only whole project but all project dependencies. Moreover similar classes in
different project can have different names, so considering class types would
significantly limit variety of similar code. By considered above reason we throw
away object information in our search engine. But there is one exclusion: we
preserve Java standard library classes, such as 'java.lang.String' which are the
same for every project.

Some expressions is normalized, for example chain of assignments, if assignment
are not related with each other we can safely reorder them. We normalize
assignment chain by reordering them in alphabetical order. Also we normalize
constant-variable boolean comparisons. In normalized comparison variable always
on left side.

Introduced in Java 6 foreach cycle can be replaced with old for cycle. Lambda
expressions in Java introduced only in Java 8. In Java lambdas semantically
are equal to callback-classes with single method. Even developer can use
lambda in every place where callback-method is accepted. So in our search engine
we do not distinguish lambdas from callback-classes.

Some kinds of expression are removed while ACT processing. This is a simple
log method calls, if statements which checks does logging is enabled or nor,
assertions and class casts. To detect logging we just have base of known logging
frameworks. Most of Java projects use SL4J, java.logging, commons-logging etc.

\subsection{Database and Maven}

Apache Maven is a build automation tool used primarily for Java projects. Maven
addresses two aspects of building software: First, it describes how software is built, 
and second, it describes its dependencies. Contrary to preceding tools like Apache
Ant it uses conventions for the build procedure, and only exceptions need to be
written down. An XML file describes the software project being built, its
dependencies on other external modules and components, the build order, 
directories, and required plug-ins. Maven dynamically downloads Java libraries
and Maven plug-ins from one or more repositories such as the Maven  Central 
Repository, and stores them in a local cache.

Build artifacts in maven repository is versioned and often provided with source
code. It allows as to trace evolution of project. In this paper we user
artifacts from Maven Central Repository. Maven Central Repository is
the default repository for Apache Maven and it serves only Open Source projects. 
According Maven Central Repository statistics in November 2014 there were over 800 
thousands artifacts.

For accessing Maven repository there is well documented Maven Plugin API for
fetching and managing artifacts.

